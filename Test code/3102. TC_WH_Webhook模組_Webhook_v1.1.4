/**
 * WH_Testcode_1_1_4_Copilot
 * Version: 1.1.4
 * Author: Copilot
 * Date: 2025-04-02 06:33:00 UTC
 */

// 1. 定義常數與配置
const CONFIG = {
  LINE_CHANNEL_SECRET: 'e137bf2f264e9b6b80f46350fb1605b6',
  DD_API_ENDPOINT: 'MOCK_DD_ENDPOINT', // 模擬DD API
  MAX_RETRY_COUNT: 3,
  RETRY_DELAY_MS: 1000
};

// 2. 定義記錄器函數
function logDebug(step, message, data = null) {
  const timestamp = new Date().toISOString();
  const logMessage = {
    timestamp,
    step,
    message,
    data: data ? JSON.stringify(data) : null
  };
  console.log(JSON.stringify(logMessage));
}

// 3. 主要的webhook處理函數
function doPost(e) {
  logDebug('1', '開始處理webhook請求', { event: e });
  
  try {
    // 4. 驗證請求格式
    if (!e || !e.postData ||!e.postData.contents) {
      logDebug('2', '請求格式無效或缺少postData');
      return createResponse(400, 'Invalid request format');
    }

    // 5. 取得並驗證LINE簽名
    const signature = e.headers ? e.headers['X-Line-Signature'] : null;
    if (!signature) {
      logDebug('3', '缺少LINE簽名');
      return createResponse(403, 'Signature required');
    }

    // 6. 取得請求內容
    const content = e.postData.contents;
    logDebug('4', '收到請求內容', { content });

    // 7. 驗證簽名
    if (!isValidSignature(content, signature)) {
      logDebug('5', '簽名驗證失敗');
      return createResponse(403, 'Invalid signature');
    }

    // 8. 解析webhook事件
    const webhookData = parseWebhookData(content);
    if (!webhookData.success) {
      logDebug('6', '解析webhook數據失敗', webhookData.error);
      return createResponse(400, 'Invalid webhook data');
    }

    // 9. 確保 webhookData 包含 events 屬性並且是數組
    if (!webhookData.data || !webhookData.data.events || !Array.isArray(webhookData.data.events)) {
      logDebug('7', 'webhookData 中缺少 events 屬性或不是數組', webhookData.data);
      return createResponse(400, 'Invalid webhook events data');
    }

    // 10. 處理webhook事件
    logDebug('8', '準備處理 events', { events: webhookData.data.events });
    return processWebhookEvents(webhookData.data);

  } catch (error) {
    logDebug('9', '處理請求時發生錯誤', { error: error.toString() });
    return createResponse(500, 'Internal server error');
  }
}

// 11. 驗證LINE簽名的函數
function isValidSignature(content, signature) {
  logDebug('10', '開始驗證簽名');
  
  try {
    const calculatedSignature = Utilities.computeHmacSha256Signature(
      content,
      CONFIG.LINE_CHANNEL_SECRET
    );
    const encodedSignature = Utilities.base64Encode(calculatedSignature);
    
    logDebug('11', '簽名比對', {
      calculated: encodedSignature,
      received: signature
    });
    
    return encodedSignature === signature;
  } catch (error) {
    logDebug('12', '簽名驗證過程發生錯誤', { error: error.toString() });
    return false;
  }
}

// 12. 解析webhook數據的函數
function parseWebhookData(content) {
  logDebug('13', '開始解析webhook數據');
  
  try {
    const data = JSON.parse(content);
    
    if (!data.events || !Array.isArray(data.events)) {
      return {
        success: false,
        error: 'Invalid events format'
      };
    }

    logDebug('14', '解析webhook數據成功', { eventsCount: data.events.length });
    return {
      success: true,
      data: data
    };
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

// 13. 處理webhook事件的函數
function processWebhookEvents(webhookData) {
  if (!webhookData || !webhookData.events || !Array.isArray(webhookData.events)) {
    logDebug('13', '無效的webhookData', { webhookData });
    return createResponse(400, 'Invalid webhook data');
  }

  logDebug('14', '開始處理events', { events: webhookData.events });
  
  try {
    // 14. 處理每個事件
    for (const event of webhookData.events) {
      if (!event || !event.type) {
        logDebug('15', '無效的事件對象', { event });
        return createResponse(400, 'Invalid event object');
      }
      const result = forwardToMockDD(event);
      if (!result.success) {
        logDebug('16', '轉發到DD失敗', result);
        return createResponse(500, 'Failed to process event');
      }
    }

    logDebug('17', '所有事件處理完成');
    return createResponse(200, 'OK');
  } catch (error) {
    logDebug('18', '處理events時發生錯誤', { error: error.toString() });
    return createResponse(500, 'Event processing error');
  }
}

// 14. 轉發到模擬DD模組的函數
function forwardToMockDD(event) {
  if (!event || !event.type) {
    logDebug('18', '無效的事件對象', { event });
    return { success: false, error: 'Invalid event object' };
  }

  logDebug('19', '開始轉發到模擬DD', { event });
  
  // 模擬DD處理邏輯
  const payload = {
    event_type: event.type,
    user_id: event.source.userId,
    timestamp: event.timestamp,
    original_text: event.message.text,
    source: 'LINE'
  };

  logDebug('20', '模擬DD接收到的payload', { payload });

  // 模擬成功回應
  return { success: true };
}

// 15. 創建HTTP回應的輔助函數
function createResponse(code, message) {
  const output = HtmlService.createHtmlOutput(message);
  output.setTitle('Response');
  output.addMetaTag('viewport', 'width=device-width, initial-scale=1');
  return output;
}

// 測試函數，用於模擬 webhook 請求
function testWebhook() {
  const tests = [
    {
      description: '測試正常的 webhook 請求',
      mockContent: JSON.stringify({
        events: [
          {
            type: 'message',
            source: {
              userId: 'U1234567890'
            },
            timestamp: 1618361234567,
            message: {
              id: '1234567890123',
              type: 'text',
              text: 'Hello, world'
            }
          }
        ]
      }),
      expectedResponse: 'OK',
      testCase: 'TC-001 測試 Webhook 事件接收'
    },
    {
      description: '測試無效簽名',
      mockContent: JSON.stringify({
        events: [
          {
            type: 'message',
            source: {
              userId: 'U1234567890'
            },
            timestamp: 1618361234567,
            message: {
              id: '1234567890123',
              type: 'text',
              text: 'Hello, world'
            }
          }
        ]
      }),
      signature: 'INVALID_SIGNATURE',
      expectedResponse: 'Invalid signature',
      testCase: 'TC-002 測試請求驗證'
    },
    {
      description: '測試無效的事件數據',
      mockContent: JSON.stringify({
        invalid: 'data'
      }),
      expectedResponse: 'Invalid webhook data',
      testCase: 'TC-005 測試解析錯誤'
    },
    {
      description: '測試 DD 無回應時的行為',
      mockContent: JSON.stringify({
        events: [
          {
            type: 'message',
            source: {
              userId: 'U1234567890'
            },
            timestamp: 1618361234567,
            message: {
              id: '1234567890123',
              type: 'text',
              text: 'Hello, world'
            }
          }
        ]
      }),
      ddResponse: { success: false, error: 'DD no response' },
      expectedResponse: 'Failed to process event',
      testCase: 'TC-004 測試 DD 無回應時的行為'
    },
    {
      description: '測試訊息轉發',
      mockContent: JSON.stringify({
        events: [
          {
            type: 'message',
            source: {
              userId: 'U1234567890'
            },
            timestamp: 1618361234567,
            message: {
              id: '1234567890123',
              type: 'text',
              text: 'Hello, world'
            }
          }
        ]
      }),
      ddResponse: { success: true },
      expectedResponse: 'OK',
      testCase: 'TC-003 測試訊息轉發'
    },
    {
      description: '測試正常回應',
      mockContent: JSON.stringify({
        events: [
          {
            type: 'message',
            source: {
              userId: 'U1234567890'
            },
            timestamp: 1618361234567,
            message: {
              id: '1234567890123',
              type: 'text',
              text: 'Hello, world'
            }
          }
        ]
      }),
      expectedResponse: 'OK',
      testCase: 'TC-006 測試正常回應'
    }
  ];

  const results = [];

  tests.forEach(test => {
    const mockRequest = {
      postData: {
        contents: test.mockContent
      },
      headers: {
        'X-Line-Signature': test.signature || 'MOCK_SIGNATURE'
      }
    };

    // 模擬 DD API 回應
    if (test.ddResponse) {
      forwardToMockDD = function(event) {
        return test.ddResponse;
      };
    }

    const response = doPost(mockRequest);
    const result = response.getContent() === test.expectedResponse ? '通過' : '未通過';
    console.log(`${test.testCase} - ${test.description}: ${result}`);
    results.push({ testCase: test.testCase, result });
  });

  // 按測試案例順序顯示測試總結
  results.sort((a, b) => a.testCase.localeCompare(b.testCase));

  console.log('測試總結:');
  results.forEach(result => console.log(`${result.testCase}: ${result.result}`));
}
