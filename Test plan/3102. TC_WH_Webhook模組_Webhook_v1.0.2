/**
 * WH test code for LINE Messaging API
 * Version: 1.0.3
 * Author: Copilot
 * Date: 2025-04-02 03:37:38 UTC
 */

// 1. 定義常數與配置
const CONFIG = {
  LINE_CHANNEL_SECRET: 'YOUR_CHANNEL_SECRET',
  DD_API_ENDPOINT: 'MOCK_DD_ENDPOINT', // 模擬DD API
  MAX_RETRY_COUNT: 3,
  RETRY_DELAY_MS: 1000
};

// 2. 定義記錄器函數
function logDebug(step, message, data = null) {
  const timestamp = new Date().toISOString();
  const logMessage = {
    timestamp,
    step,
    message,
    data: data ? JSON.stringify(data) : null
  };
  console.log(JSON.stringify(logMessage));
}

// 3. 主要的webhook處理函數
function doPost(e) {
  logDebug('1', '開始處理webhook請求', { headers: e.headers });
  
  try {
    // 4. 驗證請求格式
    if (!e.postData || !e.postData.contents) {
      logDebug('2', '請求格式無效');
      return createResponse(400, 'Invalid request format');
    }

    // 5. 取得並驗證LINE簽名
    const signature = e.headers['X-Line-Signature'];
    if (!signature) {
      logDebug('3', '缺少LINE簽名');
      return createResponse(403, 'Signature required');
    }

    // 6. 取得請求內容
    const content = e.postData.contents;
    logDebug('4', '收到請求內容', { content });

    // 7. 驗證簽名
    if (!isValidSignature(content, signature)) {
      logDebug('5', '簽名驗證失敗');
      return createResponse(403, 'Invalid signature');
    }

    // 8. 解析webhook事件
    const webhookData = parseWebhookData(content);
    if (!webhookData.success) {
      logDebug('6', '解析webhook數據失敗', webhookData.error);
      return createResponse(400, 'Invalid webhook data');
    }

    // 9. 處理webhook事件
    return processWebhookEvents(webhookData.data);

  } catch (error) {
    logDebug('7', '處理請求時發生錯誤', { error: error.toString() });
    return createResponse(500, 'Internal server error');
  }
}

// 10. 驗證LINE簽名的函數
function isValidSignature(content, signature) {
  logDebug('8', '開始驗證簽名');
  
  try {
    const calculatedSignature = Utilities.computeHmacSha256Signature(
      content,
      CONFIG.LINE_CHANNEL_SECRET
    );
    const encodedSignature = Utilities.base64Encode(calculatedSignature);
    
    logDebug('9', '簽名比對', {
      calculated: encodedSignature,
      received: signature
    });
    
    return encodedSignature === signature;
  } catch (error) {
    logDebug('10', '簽名驗證過程發生錯誤', { error: error.toString() });
    return false;
  }
}

// 11. 解析webhook數據的函數
function parseWebhookData(content) {
  logDebug('11', '開始解析webhook數據');
  
  try {
    const data = JSON.parse(content);
    
    if (!data.events || !Array.isArray(data.events)) {
      return {
        success: false,
        error: 'Invalid events format'
      };
    }

    logDebug('12', '解析webhook數據成功', { eventsCount: data.events.length });
    return {
      success: true,
      data: data
    };
  } catch (error) {
    return {
      success: false,
      error: error.toString()
    };
  }
}

// 12. 處理webhook事件的函數
function processWebhookEvents(webhookData) {
  logDebug('13', '開始處理events', { events: webhookData.events });
  
  try {
    // 13. 處理每個事件
    for (const event of webhookData.events) {
      const result = forwardToMockDD(event);
      if (!result.success) {
        logDebug('14', '轉發到DD失敗', result);
        return createResponse(500, 'Failed to process event');
      }
    }

    logDebug('15', '所有事件處理完成');
    return createResponse(200, 'OK');
  } catch (error) {
    logDebug('16', '處理events時發生錯誤', { error: error.toString() });
    return createResponse(500, 'Event processing error');
  }
}

// 14. 轉發到模擬DD模組的函數
function forwardToMockDD(event) {
  logDebug('17', '開始轉發到模擬DD', { event });
  
  // 模擬DD處理邏輯
  const payload = {
    event_type: event.type,
    user_id: event.source.userId,
    timestamp: event.timestamp,
    original_text: event.message.text,
    source: 'LINE'
  };

  logDebug('18', '模擬DD接收到的payload', { payload });

  // 模擬成功回應
  return { success: true };
}

// 15. 創建HTTP回應的輔助函數
function createResponse(code, message) {
  return ContentService.createTextOutput(message)
    .setMimeType(ContentService.MimeType.TEXT)
    .setResponseCode(code);
}
